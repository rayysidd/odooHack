import AnalyticsEvent from '../../analytics/AnalyticsEvent';
import { HMSConnectionRole } from '../../connection/model';
import { PeerNotificationInfo, SendMessage } from '../../notification-manager';
import { LEAVE_REASON } from '../../utils/constants';
import { Queue } from '../../utils/queue';
import { AcceptRoleChangeParams, BroadcastResponse, CreateWhiteboardResponse, FindPeerByNameRequestParams, FindPeerByNameResponse, FindPeersRequestParams, GetPeerRequestParams, GetSessionMetadataResponse, GetWhiteboardResponse, HLSRequestParams, HLSTimedMetadataParams, HMSPermissionType, HMSWhiteboardCreateOptions, JoinLeaveGroupResponse, MultiTrackUpdateRequestParams, PeerIterRequestParams, PeersIterationResponse, PollInfoGetParams, PollInfoSetParams, PollLeaderboardGetParams, PollLeaderboardGetResponse, PollListParams, PollListResponse, PollQuestionsGetParams, PollQuestionsGetResponse, PollQuestionsSetParams, PollQuestionsSetResponse, PollResponseSetParams, PollResponseSetResponse, PollResponsesGetParams, PollResponsesGetResponse, PollResultParams, PollResultResponse, PollStartParams, PollStartResponse, PollStopParams, RemovePeerRequest, RequestForBulkRoleChangeParams, RequestForRoleChangeParams, SetSessionMetadataParams, SetSessionMetadataResponse, StartRTMPOrRecordingRequestParams, StartTranscriptionRequestParams, Track, TrackUpdateRequestParams, UpdatePeerRequestParams } from '../interfaces';
import { ISignalEventsObserver } from '../ISignalEventsObserver';
export default class JsonRpcSignal {
    readonly TAG = "[SIGNAL]: ";
    readonly observer: ISignalEventsObserver;
    readonly pongResponseTimes: Queue<number>;
    /**
     * Sometimes before [join] is completed, there could be a lot of trickles
     * Sending [HMSTrickle]` before [join] web socket message leads to
     * error: [500] no rtc transport exists for this Peer
     *
     * We keep a list of pending trickles and send them immediately after [join]
     * is done.
     */
    private isJoinCompleted;
    private pendingTrickle;
    private socket;
    private callbacks;
    private _isConnected;
    private id;
    private sfuNodeId;
    private onCloseHandler;
    get isConnected(): boolean;
    setSfuNodeId(sfuNodeId?: string): void;
    setIsConnected(newValue: boolean, reason?: string): void;
    constructor(observer: ISignalEventsObserver);
    getPongResponseTimes(): number[];
    private internalCall;
    private notify;
    open(uri: string): Promise<void>;
    close(): Promise<void>;
    join(name: string, data: string, disableVidAutoSub: boolean, serverSubDegrade: boolean, simulcast: boolean, onDemandTracks: boolean, offer?: RTCSessionDescriptionInit): Promise<RTCSessionDescriptionInit & {
        sfu_node_id: string | undefined;
    }>;
    trickle(target: HMSConnectionRole, candidate: RTCIceCandidateInit): void;
    offer(desc: RTCSessionDescriptionInit, tracks: Map<string, any>): Promise<RTCSessionDescriptionInit>;
    answer(desc: RTCSessionDescriptionInit): void;
    trackUpdate(tracks: Map<string, Track>): void;
    broadcast(message: SendMessage): Promise<BroadcastResponse>;
    leave(reason: LEAVE_REASON): void;
    endRoom(lock: boolean, reason: string): Promise<void>;
    sendEvent(event: AnalyticsEvent): void;
    ping(timeout: number): Promise<number>;
    requestRoleChange(params: RequestForRoleChangeParams): Promise<void>;
    requestBulkRoleChange(params: RequestForBulkRoleChangeParams): Promise<void>;
    acceptRoleChangeRequest(params: AcceptRoleChangeParams): Promise<void>;
    requestTrackStateChange(params: TrackUpdateRequestParams): Promise<void>;
    requestMultiTrackStateChange(params: MultiTrackUpdateRequestParams): Promise<void>;
    removePeer(params: RemovePeerRequest): Promise<void>;
    startRTMPOrRecording(params: StartRTMPOrRecordingRequestParams): Promise<void>;
    stopRTMPAndRecording(): Promise<void>;
    startHLSStreaming(params: HLSRequestParams): Promise<void>;
    stopHLSStreaming(params?: HLSRequestParams): Promise<void>;
    startTranscription(params: StartTranscriptionRequestParams): Promise<void>;
    stopTranscription(params: StartTranscriptionRequestParams): Promise<void>;
    sendHLSTimedMetadata(params?: HLSTimedMetadataParams): Promise<void>;
    updatePeer(params: UpdatePeerRequestParams): Promise<void>;
    getPeer(params: GetPeerRequestParams): Promise<PeerNotificationInfo | undefined>;
    joinGroup(name: string): Promise<JoinLeaveGroupResponse>;
    leaveGroup(name: string): Promise<JoinLeaveGroupResponse>;
    addToGroup(peerId: string, name: string): Promise<void>;
    removeFromGroup(peerId: string, name: string): Promise<void>;
    peerIterNext(params: PeerIterRequestParams): Promise<PeersIterationResponse>;
    findPeers(params: FindPeersRequestParams): Promise<PeersIterationResponse>;
    findPeerByName(params: FindPeerByNameRequestParams): Promise<FindPeerByNameResponse>;
    setSessionMetadata(params: SetSessionMetadataParams): Promise<SetSessionMetadataResponse>;
    listenMetadataChange(keys: string[]): Promise<void>;
    getSessionMetadata(key?: string): Promise<GetSessionMetadataResponse>;
    setPollInfo(params: PollInfoSetParams): Promise<import("../interfaces").PollID>;
    getPollInfo(params: PollInfoGetParams): Promise<import("../interfaces").PollInfoParams>;
    setPollQuestions(params: PollQuestionsSetParams): Promise<PollQuestionsSetResponse>;
    startPoll(params: PollStartParams): Promise<PollStartResponse>;
    stopPoll(params: PollStopParams): Promise<PollStartResponse>;
    getPollQuestions(params: PollQuestionsGetParams): Promise<PollQuestionsGetResponse>;
    setPollResponses(params: PollResponseSetParams): Promise<PollResponseSetResponse>;
    getPollResponses(params: PollResponsesGetParams): Promise<PollResponsesGetResponse>;
    getPollsList(params: PollListParams): Promise<PollListResponse>;
    getPollResult(params: PollResultParams): Promise<PollResultResponse>;
    createWhiteboard(params: HMSWhiteboardCreateOptions): Promise<CreateWhiteboardResponse>;
    getWhiteboard(params: {
        id: string;
        permission?: Array<HMSPermissionType>;
    }): Promise<GetWhiteboardResponse>;
    fetchPollLeaderboard(params: PollLeaderboardGetParams): Promise<PollLeaderboardGetResponse>;
    private validateConnection;
    private onMessageHandler;
    private handleResponseWithId;
    private handleResponseWithMethod;
    private resolvePingOnAnyResponse;
    private rejectPendingCalls;
    private pingPongLoop;
    private call;
    private offlineListener;
    private onlineListener;
}
