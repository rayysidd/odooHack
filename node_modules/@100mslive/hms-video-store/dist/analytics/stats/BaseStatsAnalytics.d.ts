import { LocalAudioTrackAnalytics, LocalBaseSample, LocalVideoSample, LocalVideoTrackAnalytics, PublishAnalyticPayload, RemoteAudioSample, RemoteAudioTrackAnalytics, RemoteVideoSample, RemoteVideoTrackAnalytics, SubscribeAnalyticPayload } from './interfaces';
import { EventBus } from '../../events/EventBus';
import { HMSTrackStats } from '../../interfaces';
import { HMSTrack } from '../../internal';
import { HMSWebrtcStats } from '../../rtc-stats';
import { Store } from '../../sdk/store';
export declare abstract class BaseStatsAnalytics {
    protected store: Store;
    protected eventBus: EventBus;
    protected readonly sampleWindowSize: number;
    protected readonly pushInterval: number;
    private shouldSendEvent;
    protected sequenceNum: number;
    protected abstract trackAnalytics: Map<string, RunningTrackAnalytics>;
    constructor(store: Store, eventBus: EventBus, sampleWindowSize: number, pushInterval: number);
    start(): void;
    stop: () => void;
    private startLoop;
    protected sendEvent(): void;
    protected cleanTrackAnalyticsAndCreateSample(shouldCreateSample: boolean): void;
    protected abstract toAnalytics(): PublishAnalyticPayload | SubscribeAnalyticPayload;
    protected abstract handleStatsUpdate(hmsStats: HMSWebrtcStats): void;
}
export declare type TempStats = HMSTrackStats & {
    availableOutgoingBitrate?: number;
    calculatedJitterBufferDelay?: number;
    avSync?: number;
    expectedFrameHeight?: number;
    expectedFrameWidth?: number;
};
export declare abstract class RunningTrackAnalytics {
    readonly sampleWindowSize: number;
    track: HMSTrack;
    track_id: string;
    source: string;
    ssrc: string;
    kind: string;
    rid?: string;
    samples: (LocalBaseSample | LocalVideoSample | RemoteAudioSample | RemoteVideoSample)[];
    protected tempStats: TempStats[];
    protected prevLatestStat?: TempStats;
    constructor({ track, ssrc, rid, kind, sampleWindowSize, }: {
        track: HMSTrack;
        ssrc: string;
        kind: string;
        rid?: string;
        sampleWindowSize: number;
    });
    pushTempStat(stat: TempStats): void;
    createSample(): void;
    clearSamples(): void;
    abstract shouldCreateSample: () => boolean;
    protected abstract collateSample: () => LocalBaseSample | LocalVideoSample | RemoteAudioSample | RemoteVideoSample;
    protected abstract toAnalytics: () => LocalAudioTrackAnalytics | LocalVideoTrackAnalytics | RemoteAudioTrackAnalytics | RemoteVideoTrackAnalytics;
    getLatestStat(): TempStats;
    protected getFirstStat(): TempStats;
    protected calculateSum(key: keyof TempStats): number | undefined;
    protected calculateAverage(key: keyof TempStats, round?: boolean): number | undefined;
    protected calculateDifferenceForSample(key: keyof TempStats): number;
    protected calculateDifferenceAverage(key: keyof TempStats, round?: boolean): number;
    protected calculateInstancesOfHigh(key: keyof TempStats, threshold: number): number | undefined;
}
export declare const hasResolutionChanged: (newStat: TempStats, prevStat: TempStats) => boolean;
export declare const hasEnabledStateChanged: (newStat: TempStats, prevStat: TempStats) => boolean;
export declare const removeUndefinedFromObject: <T extends Record<string, any>>(data: T) => T;
