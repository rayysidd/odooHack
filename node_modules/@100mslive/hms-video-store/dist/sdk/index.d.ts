import { HMSLocalPeer } from './models/peer';
import { HMSPeerListIterator } from './HMSPeerListIterator';
import { LocalTrackManager } from './LocalTrackManager';
import { Store } from './store';
import { HMSAnalyticsLevel } from '../analytics/AnalyticsEventLevel';
import { DeviceManager } from '../device-manager';
import { AudioOutputManager } from '../device-manager/AudioOutputManager';
import { HMSDiagnosticsConnectivityListener } from '../diagnostics/interfaces';
import { HMSSessionFeedback } from '../end-call-feedback';
import { HMSChangeMultiTrackStateParams, HMSConfig, HMSConnectionQualityListener, HMSFrameworkInfo, HMSPlaylistSettings, HMSPreviewConfig, HMSRole, HMSRoleChangeRequest, HMSScreenShareConfig, TokenRequest, TokenRequestOptions } from '../interfaces';
import { HLSConfig, HLSTimedMetadata, StopHLSConfig } from '../interfaces/hls-config';
import { HMSInterface } from '../interfaces/hms';
import { HMSPeerListIteratorOptions } from '../interfaces/peer-list-iterator';
import { HMSPreviewListener } from '../interfaces/preview-listener';
import { RTMPRecordingConfig } from '../interfaces/rtmp-recording-config';
import { HMSAudioListener, HMSUpdateListener } from '../interfaces/update-listener';
import { PlaylistManager, TranscriptionConfig } from '../internal';
import { HMSRemoteTrack, HMSTrackSource, HMSVideoTrack } from '../media/tracks';
import { DebugInfo } from '../schema';
import { SessionStore } from '../session-store';
import { InteractivityCenter } from '../session-store/interactivity-center';
import { FindPeerByNameRequestParams } from '../signal/interfaces';
import { HMSLogLevel } from '../utils/logger';
export declare class HMSSdk implements HMSInterface {
    private transport;
    private readonly TAG;
    listener?: HMSUpdateListener;
    private errorListener?;
    private deviceChangeListener?;
    private audioListener?;
    store: Store;
    private notificationManager?;
    /** @internal */
    deviceManager: DeviceManager;
    private audioSinkManager;
    private playlistManager;
    private audioOutput;
    private transportState;
    private roleChangeManager?;
    /** @internal */
    localTrackManager: LocalTrackManager;
    private analyticsEventsService;
    private analyticsTimer;
    private eventBus;
    private networkTestManager;
    private wakeLockManager;
    private sessionStore;
    private interactivityCenter;
    private pluginUsageTracker;
    private sdkState;
    private frameworkInfo?;
    private isDiagnostics;
    /**
     * will be set post join
     * this will not be reset on leave but after feedback success
     * we will just clean token after successful submit feedback
     * will be replaced when a newer join happens.
     */
    private sessionPeerInfo?;
    private playlistSettings;
    private setSessionPeerInfo;
    private initNotificationManager;
    /** @internal */
    initStoreAndManagers(listener: HMSPreviewListener | HMSUpdateListener | HMSDiagnosticsConnectivityListener): void;
    private validateJoined;
    private sendHLSAnalytics;
    refreshDevices(): Promise<void>;
    getWebrtcInternals(): import("../internal").HMSWebrtcInternals | undefined;
    getDebugInfo(): DebugInfo | undefined;
    getSessionStore(): SessionStore;
    getPlaylistManager(): PlaylistManager;
    getRecordingState(): import("../interfaces").HMSRecording | undefined;
    getRTMPState(): import("../interfaces").HMSRTMP | undefined;
    getHLSState(): import("../interfaces").HMSHLS | undefined;
    getTranscriptionState(): import("../interfaces").HMSTranscriptionInfo[] | undefined;
    getTemplateAppData(): Record<string, string> | undefined;
    getInteractivityCenter(): InteractivityCenter;
    getPeerListIterator(options?: HMSPeerListIteratorOptions): HMSPeerListIterator;
    updatePlaylistSettings(options: HMSPlaylistSettings): void;
    private handleAutoplayError;
    private get localPeer();
    private observer;
    private handlePeerLeaveRequest;
    preview(config: HMSPreviewConfig, listener: HMSPreviewListener): Promise<void>;
    private handlePreviewError;
    private midCallPreview;
    cancelMidCallPreview(): Promise<void>;
    private handleDeviceChange;
    private handleAudioPluginError;
    /**
     * This is to handle errors thrown from internal handling of audio video track changes
     * For example, handling visibility change and making a new gum can throw an error which is currently
     * unhandled. This will notify the app of the error.
     * @param {HMSException} error
     */
    private handleError;
    join(config: HMSConfig, listener: HMSUpdateListener): Promise<void>;
    private stringifyMetadata;
    private cleanup;
    leave(notifyServer?: boolean): Promise<void>;
    private internalLeave;
    getAuthTokenByRoomCode(tokenRequest: TokenRequest, tokenRequestOptions?: TokenRequestOptions): Promise<string>;
    getLocalPeer(): HMSLocalPeer | undefined;
    getPeers(): import("./models/peer").HMSPeer[];
    getPeerMap(): Record<string, import("./models/peer").HMSPeer>;
    getAudioOutput(): AudioOutputManager;
    sendMessage(type: string, message: string): void;
    sendBroadcastMessage(message: string, type?: string): Promise<import("../signal/interfaces").BroadcastResponse>;
    sendGroupMessage(message: string, roles: HMSRole[], type?: string): Promise<import("../signal/interfaces").BroadcastResponse>;
    sendDirectMessage(message: string, peerId: string, type?: string): Promise<import("../signal/interfaces").BroadcastResponse>;
    submitSessionFeedback(feedback: HMSSessionFeedback, eventEndpoint?: string): Promise<void>;
    getPeer(peerId: string): Promise<import("./models/peer").HMSRemotePeer | undefined>;
    findPeerByName({ query, limit, offset }: FindPeerByNameRequestParams): Promise<{
        offset: number;
        eof: boolean;
        peers: import("./models/peer").HMSRemotePeer[];
    } | {
        offset: number;
        peers: never[];
        eof?: undefined;
    }>;
    private sendMessageInternal;
    startScreenShare(onStop: () => void, config?: HMSScreenShareConfig): Promise<void>;
    private stopEndedScreenshare;
    stopScreenShare(): Promise<void>;
    addTrack(track: MediaStreamTrack, source?: HMSTrackSource): Promise<void>;
    removeTrack(trackId: string, internal?: boolean): Promise<void>;
    setAnalyticsLevel(level: HMSAnalyticsLevel): void;
    setLogLevel(level: HMSLogLevel): void;
    autoSelectAudioOutput(delay?: number): void;
    addAudioListener(audioListener: HMSAudioListener): void;
    addConnectionQualityListener(qualityListener: HMSConnectionQualityListener): void;
    /** @internal */
    setIsDiagnostics(isDiagnostics: boolean): void;
    changeRole(forPeerId: string, toRole: string, force?: boolean): Promise<void>;
    changeRoleOfPeer(forPeerId: string, toRole: string, force?: boolean): Promise<void>;
    changeRoleOfPeersWithRoles(roles: HMSRole[], toRole: string): Promise<void>;
    acceptChangeRole(request: HMSRoleChangeRequest): Promise<void>;
    endRoom(lock: boolean, reason: string): Promise<void>;
    removePeer(peerId: string, reason: string): Promise<void>;
    startRTMPOrRecording(params: RTMPRecordingConfig): Promise<void>;
    stopRTMPAndRecording(): Promise<void>;
    startHLSStreaming(params?: HLSConfig): Promise<void>;
    stopHLSStreaming(params?: StopHLSConfig): Promise<void>;
    startTranscription(params: TranscriptionConfig): Promise<void>;
    stopTranscription(params: TranscriptionConfig): Promise<void>;
    sendHLSTimedMetadata(metadataList: HLSTimedMetadata[]): Promise<void>;
    changeName(name: string): Promise<void>;
    changeMetadata(metadata: string): Promise<void>;
    setSessionMetadata(metadata: any): Promise<void>;
    getSessionMetadata(): Promise<any>;
    getRoles(): HMSRole[];
    changeTrackState(forRemoteTrack: HMSRemoteTrack, enabled: boolean): Promise<void>;
    changeMultiTrackState(params: HMSChangeMultiTrackStateParams): Promise<void>;
    raiseLocalPeerHand(): Promise<void>;
    lowerLocalPeerHand(): Promise<void>;
    raiseRemotePeerHand(peerId: string): Promise<void>;
    lowerRemotePeerHand(peerId: string): Promise<void>;
    setFrameworkInfo(frameworkInfo: HMSFrameworkInfo): void;
    attachVideo(track: HMSVideoTrack, videoElement: HTMLVideoElement): Promise<void>;
    detachVideo(track: HMSVideoTrack, videoElement: HTMLVideoElement): Promise<void>;
    private publish;
    private getAndPublishTracks;
    private handleLocalRoleUpdate;
    private setAndPublishTracks;
    private setLocalPeerTrack;
    private initDeviceManagers;
    private cleanDeviceManagers;
    /** @internal */
    initPreviewTrackAudioLevelMonitor(): void;
    private notifyJoin;
    /**
     * Init store and other managers, setup listeners, create local peer, room
     * @param {HMSConfig} config
     * @param {HMSPreviewListener} listener
     */
    private setUpPreview;
    /**
     * Set bitrate and dimensions for playlist track
     */
    private setPlaylistSettings;
    /**
     * @param {HMSConfig} config
     * @param {string} role
     * @param {string} userId
     */
    private createAndAddLocalPeerToStore;
    /**
     * init managers and set listeners - common for join and preview
     * @param {HMSConfig} config
     * @param {string} roomId
     * @param {HMSPreviewListener | HMSUpdateListener} listener
     */
    private commonSetup;
    /**
     * Remove deviceId's passed in config for join if preview was already called
     * @param {HMSConfig} config
     */
    private removeDevicesFromConfig;
    /**
     * Get screenshare based on policy and audioOnly flag
     * @param {function} onStop
     * @param config
     * @returns
     */
    private getScreenshareTracks;
    private unpauseRemoteVideoTracks;
    private sendAudioPresenceFailed;
    private sendJoinAnalyticsEvent;
    private sendPreviewAnalyticsEvent;
    private sendAnalyticsEvent;
    private stopPlaylist;
    private applySettings;
}
