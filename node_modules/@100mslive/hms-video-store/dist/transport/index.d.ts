import ITransportObserver from './ITransportObserver';
import { AdditionalAnalyticsProperties } from '../analytics/AdditionalAnalyticsProperties';
import { AnalyticsEventsService } from '../analytics/AnalyticsEventsService';
import { AnalyticsTimer } from '../analytics/AnalyticsTimer';
import { PluginUsageTracker } from '../common/PluginUsageTracker';
import HMSSubscribeConnection from '../connection/subscribe/subscribeConnection';
import { DeviceManager } from '../device-manager';
import { HMSDiagnosticsConnectivityListener } from '../diagnostics/interfaces';
import { EventBus } from '../events/EventBus';
import { HMSICEServer, HMSRole, HMSUpdateListener } from '../interfaces';
import { HMSLocalTrack } from '../media/tracks';
import { HMSWebrtcInternals } from '../rtc-stats/HMSWebrtcInternals';
import { Store } from '../sdk/store';
import { InitConfig, InitFlags } from '../signal/init/models';
import JsonRpcSignal from '../signal/jsonrpc';
import { LEAVE_REASON } from '../utils/constants';
export default class HMSTransport {
    private observer;
    private deviceManager;
    private store;
    private eventBus;
    private analyticsEventsService;
    private analyticsTimer;
    private pluginUsageTracker;
    private state;
    private trackStates;
    private publishConnection;
    private subscribeConnection;
    private initConfig?;
    private endpoint;
    private joinParameters?;
    private retryScheduler;
    private webrtcInternals?;
    private publishStatsAnalytics?;
    private subscribeStatsAnalytics?;
    private maxSubscribeBitrate;
    private connectivityListener?;
    private sfuNodeId?;
    joinRetryCount: number;
    private publishDisconnectTimer;
    private listener?;
    private onScreenshareStop;
    private screenStream;
    constructor(observer: ITransportObserver, deviceManager: DeviceManager, store: Store, eventBus: EventBus, analyticsEventsService: AnalyticsEventsService, analyticsTimer: AnalyticsTimer, pluginUsageTracker: PluginUsageTracker);
    /**
     * Map of callbacks used to wait for an event to fire.
     * Used here for:
     *  1. publish/unpublish waits for [IPublishConnectionObserver.onRenegotiationNeeded] to complete
     */
    private readonly callbacks;
    setListener: (listener: HMSUpdateListener) => void;
    setOnScreenshareStop: (onStop: () => void) => void;
    getWebsocketEndpoint(): string | undefined;
    private signalObserver;
    readonly signal: JsonRpcSignal;
    private analyticsSignalTransport;
    private publishDtlsStateTimer;
    private lastPublishDtlsState;
    getWebrtcInternals(): HMSWebrtcInternals | undefined;
    isFlagEnabled(flag: InitFlags): boolean;
    setConnectivityListener(listener: HMSDiagnosticsConnectivityListener): void;
    preview(token: string, endpoint: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, autoSubscribeVideo?: boolean, iceServers?: HMSICEServer[]): Promise<InitConfig | void>;
    join(authToken: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, initEndpoint: string, autoSubscribeVideo?: boolean, iceServers?: HMSICEServer[]): Promise<void>;
    connect(token: string, endpoint: string, peerId: string, customData: {
        name: string;
        metaData: string;
    }, autoSubscribeVideo?: boolean, iceServers?: HMSICEServer[]): Promise<InitConfig | void>;
    leave(notifyServer: boolean, reason?: LEAVE_REASON): Promise<void>;
    handleLocalRoleUpdate: ({ oldRole, newRole }: {
        oldRole: HMSRole;
        newRole: HMSRole;
    }) => Promise<void>;
    publish(tracks: Array<HMSLocalTrack>): Promise<void>;
    unpublish(tracks: Array<HMSLocalTrack>): Promise<void>;
    setSFUNodeId(id?: string): void;
    handleSFUMigration(): Promise<void>;
    /**
     * TODO: check if track.publishedTrackId be used instead of the hack to match with track with same type and
     * source. The hack won't work if there are multiple tracks with same source and type.
     */
    trackUpdate(track: HMSLocalTrack, enabled: boolean): void;
    private publishTrack;
    private unpublishTrack;
    private clearPeerConnections;
    private waitForLocalRoleAvailability;
    private createConnectionsAndNegotiateJoin;
    private createPeerConnections;
    private negotiateJoinWithRetry;
    private negotiateJoin;
    private negotiateJoinWebRTC;
    private negotiateJoinNonWebRTC;
    /**
     * Negotiate on first publish after changing role from non-webrtc peer to webrtc peer by sending offer
     */
    private negotiateOnFirstPublish;
    private performPublishRenegotiation;
    private handleIceConnectionFailure;
    private internalConnect;
    private validateNotDisconnected;
    private openSignal;
    private initStatsAnalytics;
    private getValueFromInitConfig;
    /**
     * Role does not need WebRTC(peer connections to communicate to SFU) if it cannot publish or subscribe to anything
     * @returns boolean denoting if a peer cannot publish(video, audio or screen) and cannot subscribe to any role
     */
    private doesRoleNeedWebRTC;
    private doesLocalPeerNeedWebRTC;
    private retryPublishIceFailedTask;
    private retrySubscribeIceFailedTask;
    private retrySignalDisconnectTask;
    private setTransportStateForConnect;
    private sendErrorAnalyticsEvent;
    getSubscribeConnection(): HMSSubscribeConnection | null;
    getAdditionalAnalyticsProperties(): AdditionalAnalyticsProperties;
}
